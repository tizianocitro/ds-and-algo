# !difficulty: hard, !from: https://www.designgurus.io/course-play/grokking-the-coding-interview/doc/639dc70fef27e08651fb4a59

'''Problem:
Given a word, write a function to generate all of its unique generalized abbreviations.

A generalized abbreviation of a word can be generated by replacing each substring of the word with the count of characters in the substring.
Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”.
After replacing these substrings in the actual word by the count of characters,
we get all the generalized abbreviations:“ab”, “1b”, “a1”, and “2”.

Note: All contiguous characters should be considered one substring,
e.g., we can’t take “a” and “b” as substrings to get “11”; since “a” and “b” are contiguous,
we should consider them together as one substring to get an abbreviation “2”.

Given word consists of only lowercase English letters.

Input: "BAT"
Output: "BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"

Input: "code"
Output: "code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2", "2de", "2d1", "3e", "4"
'''

# solution one
# Complexity:
# O(n*2^n) time - where n is the length of the input string
# each character in the string will have two abbreviation, either it is added as is or it is replaced by a number
# and each time we add a character to the abbreviation we need to iterate/copy the abbreviation string
# O(n*2^n) space - where n is the length of the input string
# this is because we will have a maximum of 2^n abbreviations, each abbreviation will have a length of n
from collections import deque

class AbbreviatedWord:
    def __init__(self, str, start,  count):
        self.str = str
        self.start = start
        self.count = count

class Solution:
    def generateGeneralizedAbbreviation(self, word):
        ln = len(word)
        if ln < 1:
            return ['']

        result = []

        # build the queue with the first letter and '1' as starting points
        queue = deque()
        queue.append(AbbreviatedWord(word[0], 1, 0))
        queue.append(AbbreviatedWord('1', 1, 1))

        while queue:
            abbr = queue.popleft()

            # we have reached the max len for the abbreviation
            if abbr.start >= ln:
                result.append(abbr.str)
            else:
                # we have not reached the max len for the abbreviation,
                # so we can add another chart by taking the char in the word at index start
                if abbr.start < ln:
                    queue.append(AbbreviatedWord(abbr.str + word[abbr.start], abbr.start + 1, abbr.count))

                # we also need to consider the abbreviation contaning a number using the count
                # if the count == 0 we just add count + 1 (where count is 0 currently)
                if abbr.count == 0:
                    queue.append(AbbreviatedWord(abbr.str + str(abbr.count + 1), abbr.start + 1, abbr.count + 1))
                else:
                    # if count > 0 we need to differentiate between two cases:
                    # last char is a letter (alpha) or a number (digit)
                    if abbr.str[-1].isalpha():
                        # we need to reset the count to 1 because even though count > 0
                        # because of numbers already in the word, the last char is now a letter,
                        # thus the next number we add to the word must be 1 again,
                        # e.g., (str: '1A', start: 2, count: 1), it would resut in '1A2' if we just added count + 1
                        # thus we restart count from 0
                        queue.append(AbbreviatedWord(abbr.str + '1', abbr.start + 1, 1))
                    else:
                        # cannot modify string, so we copy it
                        new_word = list(abbr.str)
                        # an alternative at using str(abbr.count + 1) can be
                        # just taking the last char and increasing it by 1, like:
                        # str_list[-1] = str(int(str_list[-1]) + 1)
                        new_word[-1] = str(abbr.count + 1)
                        queue.append(AbbreviatedWord(''.join(new_word), abbr.start + 1, abbr.count + 1))

        return result

# solution two
# Complexity:
# O(n*2^n) time - where n is the length of the input string
# O(n*2^n) space - where n is the length of the input string
from collections import deque

class AbbreviatedWord:

    def __init__(self, str, start,  count):
        self.str = str
        self.start = start
        self.count = count

class Solution:
    def generateGeneralizedAbbreviation(self, word):
        wordLen = len(word)
        if wordLen < 1:
            return ['']

        result = []
        queue = deque()
        queue.append(AbbreviatedWord(list(), 0, 0))

        while queue:
            abbr = queue.popleft()

            if abbr.start == wordLen:
                if abbr.count != 0:
                    abbr.str.append(str(abbr.count))
                result.append(''.join(abbr.str))
            else:
                # continue abbreviating by incrementing the current abbreviation count
                queue.append(AbbreviatedWord(list(abbr.str), abbr.start + 1, abbr.count + 1))

                # restart abbreviating, append the count and the current character to the string
                if abbr.count != 0:
                    abbr.str.append(str(abbr.count))

                    new_word = list(abbr.str)
                    new_word.append(word[abbr.start])
                    queue.append(AbbreviatedWord(new_word, abbr.start + 1, 0))

        return result

# # solution three recursive
# Complexity:
# O(n*2^n) time - where n is the length of the input string
# O(n*2^n) space - where n is the length of the input string
class Solution:
    def generateGeneralizedAbbreviation(self, word):
        result = []
        self.generate_abbreviation_recursive(word, list(), 0, 0, result)
        return result

    def generate_abbreviation_recursive(self, word, abWord, start, count, result):
        if start == len(word):
            if count != 0:
                abWord.append(str(count))
            result.append(''.join(abWord))
        else:
            # continue abbreviating by incrementing the current abbreviation count
            self.generate_abbreviation_recursive(word, list(abWord), start + 1, count + 1, result)

            # restart abbreviating, append the count and the current character to the string
            if count != 0:
                abWord.append(str(count))
            newWord = list(abWord)
            newWord.append(word[start])
            self.generate_abbreviation_recursive(word, newWord, start + 1, 0, result)
